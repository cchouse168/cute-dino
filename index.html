<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>恐龍跳躍遊戲</title>
  <!--
    單檔（HTML+CSS+JS）恐龍跳躍遊戲
    版本：V4.9（Hotfix 2025-09-29）
    更新：
    - 修正：重複宣告變數 `mgOn` 造成 SyntaxError 的問題（第二次宣告已移除，改為重用第一次宣告的值）。
    - 依分數皮膚進化：每 1000 分更換一次外觀，至 10000 分後固定為「金色」皮膚。
    - 跟隨的小小恐龍隊列距離加大：與本體的起始距離、以及彼此之間的間距皆放大。
  -->

  <!-- Favicon / Icons（用 URL 編碼單行 SVG，避免解析問題） -->
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop offset='0' stop-color='%2360a5fa'/%3E%3Cstop offset='1' stop-color='%238b5cf6'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='64' height='64' rx='12' fill='url(%23g)'/%3E%3Cg fill='%230b1020'%3E%3Crect x='18' y='28' width='28' height='16' rx='4'/%3E%3Crect x='34' y='18' width='18' height='12' rx='4'/%3E%3Crect x='22' y='44' width='8' height='10' rx='3'/%3E%3Crect x='34' y='44' width='8' height='10' rx='3'/%3E%3Ccircle cx='48' cy='22' r='2.2' fill='%23fff'/%3E%3Ccircle cx='48' cy='22' r='1.1'/%3E%3C/g%3E%3C/svg%3E"/>
  <link rel="mask-icon" color="#0b1020" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect x='18' y='28' width='28' height='16' rx='4'/%3E%3Crect x='34' y='18' width='18' height='12' rx='4'/%3E%3Crect x='22' y='44' width='8' height='10' rx='3'/%3E%3Crect x='34' y='44' width='8' height='10' rx='3'/%3E%3C/svg%3E"/>
  <meta name="theme-color" content="#0b1020"/>
  <meta name="msapplication-TileColor" content="#0b1020"/>

  <style>
    :root{ --bg:#f6f7fb; --fg:#1f2937; --danger:#ef4444; --night-sky1:#0b1020; --night-sky2:#0f172a; --night-fg:#e5e7eb; }
    html,body{height:100%}
    body{margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans TC","PingFang TC","Microsoft JhengHei",sans-serif; background:var(--bg); color:var(--fg); display:grid; place-items:center}
    .wrap{width:100vw; height:100vh; display:flex; flex-direction:column}
    header{display:flex;justify-content:space-between;align-items:center;margin:12px 0 6px 0}
    h1{font-size:clamp(18px,2.6vw,26px);margin:0;letter-spacing:.02em}
    .btns{display:flex;gap:8px;align-items:center}
    button{ border:0; padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:700; background:#fff; box-shadow:0 2px 8px rgba(0,0,0,.06) }
    button.danger{background:var(--danger); color:#fff}
    #game{width:100%; aspect-ratio:20/9; background:linear-gradient(#cfe8ff 0%, #eaf5ff 40%, #f6f7fb 100%); border-radius:16px; box-shadow:0 8px 20px rgba(0,0,0,.08); overflow:hidden; position:relative}
    #game.night{ background:linear-gradient(var(--night-sky1) 0%, var(--night-sky2) 70%) }
    .fs-btn{ position:absolute; top:10px; right:10px; z-index:20; padding:8px 12px; border-radius:12px; border:0; background:rgba(255,255,255,.9); box-shadow:0 2px 8px rgba(0,0,0,.12); font-weight:700; cursor:pointer }
    #game.night .fs-btn{ background:rgba(17,24,39,.8); color:var(--night-fg) }
    canvas{width:100%; height:100%; display:block}
    .hud{position:absolute; inset:auto 12px 12px 12px; display:flex; gap:8px; justify-content:flex-start; pointer-events:none; flex-wrap:wrap}
    .pill{background:rgba(255,255,255,.8); backdrop-filter: blur(6px); padding:8px 12px; border-radius:999px; font-size:14px; box-shadow:0 2px 8px rgba(0,0,0,.08)}
    #game.night .pill{background:rgba(17,24,39,.65); color:var(--night-fg)}
    .center-tip{position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); text-align:center}
    .center-tip .card{background:rgba(255,255,255,.92); padding:16px 18px; border-radius:16px; box-shadow:0 10px 24px rgba(0,0,0,.12)}
    #game.night .center-tip .card{background:rgba(17,24,39,.92); color:var(--night-fg)}
    .muted{opacity:.7}
    @media (max-width: 768px){ header{display:none} #game{border-radius:0; box-shadow:none} body{place-items:stretch} }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>恐龍跳躍遊戲 · 長按空白鍵/螢幕跳更高 · ↓/S 蹲下（恐龍在左側，可前後移動）</h1>
      <div class="btns">
        <button id="btnPause">暫停(P)</button>
        <button id="btnRestart" class="danger">重新開始(R)</button>
        <button id="btnAudio" title="開/關音效 (M)">🔊 音效：開(M)</button>
        <input id="vol" type="range" min="0" max="1" step="0.01" value="0.6" title="音量" style="width:120px">
      </div>
    </header>

    <div id="game">
      <button class="fs-btn" id="fsBtn" type="button" aria-label="全螢幕">全螢幕</button>
      <canvas id="canvas" width="1280" height="576" aria-label="遊戲畫面"></canvas>

      <div class="hud">
        <div class="pill" id="score">分數：0</div>
        <div class="pill" id="speed">速度：1.0×</div>
        <div class="pill" id="buff" style="display:none">無敵剩餘：0.0s</div>
        <div class="pill" id="mgHud" style="display:none">機關槍：0.0s</div>
      </div>

      <!-- HP HUD（主體 1 + 小小恐龍數） -->
      <div class="hud" style="position:absolute; left:12px; top:12px; right:auto; bottom:auto; gap:8px; pointer-events:none">
        <div class="pill" id="hpHud">HP：1</div>
      </div>

      <!-- 結束提示卡（僅在 Game Over 顯示） -->
      <div class="center-tip" id="centerTip" style="display:none">
        <div class="card">
          <div style="font-size:18px; font-weight:800; margin-bottom:10px">遊戲結束！</div>
          <div class="muted" style="font-size:14px; margin-bottom:10px">按 R 重來 · 空白鍵跳躍（可長按） · ↓/S 蹲下</div>
          <div id="tapRestart" style="display:flex;align-items:center;justify-content:center;gap:10px;user-select:none">
            <svg width="36" height="36" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
              <path d="M3 12a9 9 0 1 0 3-6.708" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M3 4v4h4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <span style="font-weight:700">點一下螢幕即可重來</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
  /* Version: V4.9 — Hotfix 2025-09-29
     修正：移除第二次宣告 mgOn，避免 "Identifier 'mgOn' has already been declared"。
     變更：
     1) 每 1000 分更換一次皮膚（tier 0~9），>=10000 分固定為金色（tier 10）。
     2) 跟隨隊列距離加大（起始距離與每隻間距皆提高）。
  */
  (function(){
    /* =============================
       變數/DOM 取得與畫面適配
       ============================= */
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const speedEl = document.getElementById('speed');
    const buffEl  = document.getElementById('buff');
    const mgHud   = document.getElementById('mgHud');
    const hpHud   = document.getElementById('hpHud');
    const tip     = document.getElementById('centerTip');
    const btnPause   = document.getElementById('btnPause');
    const btnRestart = document.getElementById('btnRestart');
    const btnFS      = document.getElementById('fsBtn');
    const btnAudio   = document.getElementById('btnAudio');
    const volEl      = document.getElementById('vol');
    const gameDiv    = document.getElementById('game');

    function fitCanvas(){
      const vw = window.innerWidth, vh = window.innerHeight;
      let targetW = vw, targetH = Math.floor(vw * 9/20); // 20:9 比例
      if(targetH > vh){ targetH = vh; targetW = Math.floor(vh * 20/9); }
      gameDiv.style.width  = targetW + 'px';
      gameDiv.style.height = targetH + 'px';
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      canvas.width  = Math.floor(targetW * dpr);
      canvas.height = Math.floor(targetH * dpr);
      canvas.style.width  = targetW + 'px';
      canvas.style.height = targetH + 'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    window.addEventListener('resize', fitCanvas); fitCanvas();

    /* ---------- 全螢幕 ---------- */
    function isFullscreen(){ return document.fullscreenElement || document.webkitFullscreenElement; }
    function updateFSUI(){ btnFS.textContent = isFullscreen()? '退出全螢幕' : '全螢幕'; }
    async function toggleFullscreen(){
      const el = gameDiv; const doc=document;
      const enter = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen || el.mozRequestFullScreen;
      const exit  = doc.exitFullscreen || doc.webkitExitFullscreen || doc.msExitFullscreen || doc.mozCancelFullScreen;
      try{
        if(!isFullscreen()){
          if(enter) await enter.call(el); else if(document.documentElement.requestFullscreen) await document.documentElement.requestFullscreen();
        }else{
          if(exit) await exit.call(doc);
        }
      }catch(e){ console.warn('Fullscreen error', e); }
      updateFSUI(); fitCanvas();
      try{ await window.screen.orientation?.lock?.('landscape'); }catch(_){/* 忽略 */}
    }
    btnFS.addEventListener('click', toggleFullscreen);
    document.addEventListener('fullscreenchange', ()=>{ updateFSUI(); fitCanvas(); });
    document.addEventListener('webkitfullscreenchange', ()=>{ updateFSUI(); fitCanvas(); });
    document.addEventListener('keydown', e=>{ if(e.key==='f'||e.key==='F') toggleFullscreen(); });

    /* =============================
       音效（SFX only）
       ============================= */
    let AC=null, master=null, noiseBuf=null; const audio={enabled:true, volume:0.6, started:false};
    function ensureAudio(){ if(AC) return; AC=new (window.AudioContext||window.webkitAudioContext)(); master=AC.createGain(); master.gain.value=audio.volume; master.connect(AC.destination); const len=AC.sampleRate*1.0; noiseBuf=AC.createBuffer(1,len,AC.sampleRate); const data=noiseBuf.getChannelData(0); for(let i=0;i<len;i++){ data[i]=(Math.random()*2-1)*(1-i/len);} audio.started=true; }
    function setVolume(v){ audio.volume=v; if(master) master.gain.value=v; }
    function tone(freq=440,dur=0.12,type='square',gain=0.25){ if(!AC) return; const o=AC.createOscillator(); const g=AC.createGain(); o.type=type; o.frequency.value=freq; o.connect(g); g.connect(master); const t=AC.currentTime; g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(gain,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+dur); o.start(t); o.stop(t+dur+0.05); }
    function noise(dur=0.18,gain=0.35,lp=1200){ if(!AC) return; const src=AC.createBufferSource(); src.buffer=noiseBuf; const f=AC.createBiquadFilter(); f.type='lowpass'; f.frequency.value=lp; const g=AC.createGain(); g.gain.value=gain; src.connect(f); f.connect(g); g.connect(master); const t=AC.currentTime; src.start(t); src.stop(t+dur); }
    const sfx={ jump:()=>{tone(660,0.10,'sine',0.22); tone(880,0.08,'triangle',0.16);}, pickup:()=>{tone(880,0.08,'sine',0.18); tone(1175,0.08,'sine',0.16);}, star:()=>{tone(523,0.10,'triangle',0.16); tone(784,0.14,'triangle',0.16); tone(1046,0.16,'triangle',0.14);}, starHit:()=>{noise(0.06,0.28,2600); tone(1500,0.05,'square',0.12);}, gun:()=>{tone(220,0.05,'square',0.18); noise(0.06,0.25,1800);}, shoot:()=>{noise(0.05,0.22,2400); tone(1200,0.04,'square',0.12);}, hit:()=>{noise(0.12,0.32,900); tone(120,0.08,'sawtooth',0.14);}, mgBurst:()=>{noise(0.03,0.22,2600); tone(1100,0.02,'square',0.10);}, over:()=>{tone(392,0.20,'sine',0.18); tone(349,0.22,'sine',0.16); tone(329,0.24,'sine',0.14);}, toggle:()=>{tone(660,0.06,'sine',0.14);} };
    btnAudio?.addEventListener('click', ()=>{ audio.enabled=!audio.enabled; if(audio.enabled){ ensureAudio(); if(AC?.state==='suspended') AC.resume(); sfx.toggle(); } else { if(AC?.state==='running') AC.suspend(); } btnAudio.textContent=(audio.enabled?'🔊 音效：開(M)':'🔈 音效：關(M)'); });
    volEl?.addEventListener('input', e=> setVolume(parseFloat(e.target.value||'0.6')));
    document.addEventListener('keydown', e=>{ if(e.key==='m'||e.key==='M') btnAudio.click(); });

    /* =============================
       遊戲狀態
       ============================= */
    const W=()=>canvas.clientWidth, H=()=>canvas.clientHeight, LEFT_X=()=>Math.max(80,W()*0.08);
    const state={
      running:false, paused:false, dead:false,
      time:0, nextSpeedUpAt:12,
      speed:300, speedScale:1, speedUpEvery:12,
      gravity:1800, jumpV:-820,
      score:0, best:0,
      obstacles:[], clouds:[], bullets:[], powerups:[], particles:[],
      palmWaves:0,
      invincibleUntil:0, night:false, littles:0,
      mgUntil:0, mgFireRate:10, mgFireTimer:0,
      pBullets:[],
      jetCooldown:0,
      holdingJump:false, jumpHold:0, jumpHoldMax:0.18
    };
    const dino={ x:LEFT_X(), y:0, w:70, h:70, baseH:70, crouchH:46, vy:0, onGround:true, vx:0, crouch:false };
    function groundY(){ return H()-80; }

    function reset(){
      state.running=false; state.paused=false; state.dead=false;
      state.time=0; state.nextSpeedUpAt=state.speedUpEvery;
      state.speedScale=1; state.score=0;
      state.obstacles.length=0; state.clouds.length=0; state.bullets.length=0; state.powerups.length=0; state.particles.length=0; state.pBullets.length=0;
      state.palmWaves=0; state.invincibleUntil=0; state.night=false; state.littles=0;
      state.mgUntil=0; state.mgFireTimer=0; state.jetCooldown=0;
      state.holdingJump=false; state.jumpHold=0;
      gameDiv.classList.remove('night');
      dino.x=LEFT_X(); dino.h=dino.baseH; dino.y=groundY()-dino.h; dino.vy=0; dino.vx=0; dino.onGround=true; dino.crouch=false;
      for(let i=0;i<6;i++) state.clouds.push({x:Math.random()*W(), y:40+Math.random()*H()*0.4, r:20+Math.random()*30, layer:0.3+Math.random()*0.4});
      tip.style.display='none';
      draw(0);
    }
    function start(){ if(!state.running && !state.dead){ state.running=true; lastTs=performance.now(); requestAnimationFrame(loop); tip.style.display='none'; }}
    function pauseToggle(){ if(!state.running) return; state.paused=!state.paused; btnPause.textContent= state.paused? '繼續(P)' : '暫停(P)'; if(!state.paused){ lastTs=performance.now(); requestAnimationFrame(loop);} }
    function restart(){ reset(); start(); }
    function rand(a,b){ return a+Math.random()*(b-a); }

    function attemptQuickRestart(){ if(state.dead){ restart(); return true; } return false; }

    function handlePress(e){ e.preventDefault(); if(attemptQuickRestart()) return; if(!state.running) start(); if(dino.onGround) doJump(); state.holdingJump=true; }
    function handleRelease(){ state.holdingJump=false; }
    gameDiv.addEventListener('pointerdown', handlePress);
    gameDiv.addEventListener('pointerup', handleRelease);
    gameDiv.addEventListener('pointercancel', handleRelease);
    gameDiv.addEventListener('pointerleave', handleRelease);

    /* =============================
       生成：障礙與道具
       ============================= */
    function spawnObstacle(){
      const baseX=W()+60; 
      let t='cactus'; const r=Math.random();
      if(r<0.50) t='cactus'; else if(r<0.80) t='palm'; else if(r<0.88) t='dragon'; else t='jet';
      if(t==='jet' && state.jetCooldown>0) t=(Math.random()<0.5?'cactus':'palm');

      if(t==='cactus'){
        const h=40+Math.random()*60; state.obstacles.push({type:t,x:baseX,y:groundY()-h,w:22,h});
      } else if(t==='dragon'){
        const w=88,h=54; const yBase=groundY()-(160+Math.random()*140);
        const amp=rand(40,80), freq=rand(0.9,1.6), phase=Math.random()*Math.PI*2;
        state.obstacles.push({type:t,x:baseX,y:yBase,w,h, y0:yBase, amp, freq, phase});
      } else if(t==='jet'){
        const h=28,w=90; const yBase=groundY()-(120+Math.random()*140); const amp=rand(20,70), freq=rand(0.6,1.2), phase=Math.random()*Math.PI*2;
        state.obstacles.push({type:t,x:baseX,y:yBase,w,h, shootTimer: rand(0.6,1.8), fired:false, y0:yBase, amp, freq, phase});
        state.jetCooldown = 3 + Math.random()*2; 
      } else {
        const h=60+Math.random()*40,w=40; state.obstacles.push({type:t,x:baseX,y:groundY()-h,w,h});
      }
    }
    function spawnPowerup(){
      const r=Math.random(); const baseX=W()+60;
      if(r<0.50){ const w=34,h=28; state.powerups.push({type:'chest',x:baseX,y:groundY()-h,w,h}); }
      else if(r<0.70){ const w=32,h=32; const y= groundY() - (90 + Math.random()*120); state.powerups.push({type:'star',x:baseX,y,w,h, spin:0}); }
      else if(r<0.85){ const w=52,h=28; const y= groundY() - (70 + Math.random()*120); state.powerups.push({type:'gun',x:baseX,y,w,h, wiggle:0}); }
      else { const w=30,h=24; const y= groundY() - h; state.powerups.push({type:'mini',x:baseX,y,w,h}); }
    }
    let spawnTimer=0, powerTimer=3.5; 

    /* =============================
       操作：鍵盤 + 觸控（支援長按可變跳高）
       ============================= */
    const keys={left:false,right:false,down:false};
    function doJump(){ 
      if(state.dead) return; if(audio.enabled && !audio.started) ensureAudio(); start();
      if(dino.onGround){ dino.vy=state.jumpV; dino.onGround=false; state.holdingJump=true; state.jumpHold=0; dino.crouch=false; if(audio.enabled) sfx.jump(); }
    }
    document.addEventListener('keydown', e=>{
      if(e.code==='Space'){ e.preventDefault(); if(state.dead) return; if(!state.running) start(); if(dino.onGround) doJump(); state.holdingJump=true; }
      if(e.key==='p'||e.key==='P') pauseToggle();
      if(e.key==='r'||e.key==='R') restart();
      if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') keys.left=true;
      if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') keys.right=true;
      if(e.key==='ArrowDown'||e.key==='s'||e.key==='S'){ keys.down=true; if(dino.onGround) dino.crouch=true; }
    });
    document.addEventListener('keyup', e=>{
      if(e.code==='Space') state.holdingJump=false;
      if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') keys.left=false;
      if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') keys.right=false;
      if(e.key==='ArrowDown'||e.key==='s'||e.key==='S'){ keys.down=false; dino.crouch=false; }
    });
    btnPause.addEventListener('click', ()=>pauseToggle());
    btnRestart.addEventListener('click', ()=>restart());

    /* =============================
       輔助：碰撞與粒子
       ============================= */
    function intersects(a,b){ return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y; }
    function spawnSparks(x,y,n=20,baseV=340,life=0.6,size=4,colorDay='#ffd166',colorNight='#ffffff'){
      for(let i=0;i<n;i++){
        const ang=Math.random()*Math.PI - Math.PI/2; 
        const spd=baseV*(0.5+Math.random());
        state.particles.push({x,y, vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd*0.6-20, life:life*(0.8+Math.random()*0.4), age:0, size, colorDay, colorNight});
      }
    }

    /* =============================
       主迴圈（update → draw）
       ============================= */
    let lastTs=0; function loop(ts){ if(!state.running||state.paused) return; const dt=Math.min(0.032,(ts-lastTs)/1000); lastTs=ts; update(dt); draw(dt); requestAnimationFrame(loop); }
    function isNightForScore(score){ return (Math.floor(score/1000)%2)===1; }

    function update(dt){
      state.time+=dt;
      if(state.time >= state.nextSpeedUpAt){ state.speedScale=Math.min(2.0,state.speedScale+0.04); state.nextSpeedUpAt += state.speedUpEvery; }

      const targetH=(dino.crouch && dino.onGround)? dino.crouchH : dino.baseH; if(targetH!==dino.h){ const feet=dino.y+dino.h; dino.h=targetH; dino.y=feet-dino.h; }

      dino.vy += state.gravity*dt;
      if(state.holdingJump && !dino.onGround && dino.vy<0 && state.jumpHold<state.jumpHoldMax){ dino.vy += -1200*dt; state.jumpHold += dt; }
      if((!state.holdingJump || state.jumpHold>=state.jumpHoldMax) && dino.vy<0){ dino.vy += 1200*dt; }

      dino.y += dino.vy*dt; if(dino.y+dino.h>=groundY()){ dino.y=groundY()-dino.h; dino.vy=0; dino.onGround=true; state.jumpHold=0; state.holdingJump=false; } else dino.onGround=false;
      const ax=(keys.left?-1400:0)+(keys.right?1400:0); dino.vx += ax*dt; dino.vx *= 0.88; const maxV=360; dino.vx=Math.max(-maxV,Math.min(maxV,dino.vx)); dino.x += dino.vx*dt; const minX=LEFT_X(), maxX=W()*0.6; if(dino.x<minX){ dino.x=minX; dino.vx=0; } if(dino.x>maxX){ dino.x=maxX; dino.vx=0; }

      spawnTimer -= dt; state.jetCooldown=Math.max(0,state.jetCooldown-dt);
      if(spawnTimer<=0){ spawnObstacle(); const worldVForGap=state.speed*state.speedScale; const gapPx=rand(360,720); spawnTimer = gapPx/Math.max(120,worldVForGap); }
      powerTimer -= dt; if(powerTimer<=0){ powerTimer=5.5+Math.random()*4.5; spawnPowerup(); }

      const worldV=state.speed*state.speedScale;

      for(const ob of state.obstacles){
        ob.x -= worldV*dt;
        if(ob.type==='jet'){
          ob.y = ob.y0 + Math.sin(state.time*ob.freq + ob.phase)*ob.amp; 
          ob.shootTimer -= dt; 
          if(!ob.fired && ob.shootTimer<=0){ ob.fired=true; const bx=ob.x-6, by=ob.y+ob.h*0.5; state.bullets.push({x:bx,y:by,w:10,h:4,v:worldV+420}); if(audio.enabled) sfx.shoot(); }
        } else if(ob.type==='dragon'){
          ob.y = ob.y0 + Math.sin(state.time*ob.freq + ob.phase)*ob.amp; 
        }
      }
      state.obstacles = state.obstacles.filter(ob=> ob.x+ob.w > -80);

      for(const b of state.bullets){ b.x -= b.v*dt; }
      state.bullets = state.bullets.filter(b=> b.x+b.w > -60);

      for(const p of state.powerups){ p.x -= worldV*0.9*dt; if(p.type==='star') p.spin += dt*6; if(p.type==='gun'){ p.wiggle += dt*4; p.y += Math.sin(p.wiggle)*0.3; } }
      state.powerups = state.powerups.filter(p=> p.x+p.w > -60);

      state.score += worldV*dt*0.02; scoreEl.textContent=`分數：${Math.floor(state.score)}`; speedEl.textContent=`速度：${state.speedScale.toFixed(1)}×`;
      const nightNow = isNightForScore(state.score); if(state.night!==nightNow){ state.night=nightNow; if(nightNow) gameDiv.classList.add('night'); else gameDiv.classList.remove('night'); }

      const inv = (state.time < state.invincibleUntil); buffEl.style.display= inv? '' : 'none'; if(inv) buffEl.textContent=`無敵剩餘：${Math.max(0,(state.invincibleUntil-state.time)).toFixed(1)}s`;
      const mgOn=(state.time<state.mgUntil); mgHud.style.display= mgOn? '' : 'none'; if(mgOn) mgHud.textContent=`機關槍：${Math.max(0,(state.mgUntil-state.time)).toFixed(1)}s`;
      hpHud.textContent = `HP：${1+state.littles}`;

      const dbox={x:dino.x-dino.w*0.45, y:dino.y, w:dino.w*0.9, h:dino.h};
      for(let i=state.powerups.length-1;i>=0;i--){ const p=state.powerups[i]; if(intersects(dbox,p)){
        if(p.type==='chest'){ state.score+=100; if(audio.enabled) sfx.pickup(); }
        else if(p.type==='star'){ state.invincibleUntil = state.time+6.0; if(audio.enabled) sfx.star(); }
        else if(p.type==='gun'){ state.mgUntil = state.time+6.0; state.mgFireTimer=0; if(audio.enabled) sfx.gun(); }
        else if(p.type==='mini'){ state.littles++; if(audio.enabled) sfx.pickup(); }
        state.powerups.splice(i,1);
      }}

      if(inv){
        for(let j=state.obstacles.length-1;j>=0;j--){ const ob=state.obstacles[j]; if(intersects(dbox,{x:ob.x,y:ob.y,w:ob.w,h:ob.h})){ spawnSparks(ob.x+ob.w*0.5, ob.y+ob.h*0.5,22,360,0.7,5); if(audio.enabled) sfx.starHit(); state.obstacles.splice(j,1);} }
        for(let k=state.bullets.length-1;k>=0;k--){ const b=state.bullets[k]; if(intersects(dbox,b)){ spawnSparks(b.x,b.y,14,320,0.6,4); if(audio.enabled) sfx.starHit(); state.bullets.splice(k,1);} }
      }
      if(!inv){
        let collided=false;
        for(let j=state.obstacles.length-1;j>=0;j--){ const ob=state.obstacles[j]; if(intersects(dbox,{x:ob.x,y:ob.y,w:ob.w,h:ob.h})){ collided=true; spawnSparks(ob.x+ob.w*0.5, ob.y+ob.h*0.5,20,340,0.6,4); state.obstacles.splice(j,1); break; }}
        for(let k=state.bullets.length-1;k>=0 && !collided;k--){ const b=state.bullets[k]; if(intersects(dbox,b)){ collided=true; spawnSparks(b.x,b.y,14,320,0.5,4); state.bullets.splice(k,1); break; }}
        if(collided){ if(state.littles>0){ state.littles--; if(audio.enabled) sfx.hit(); } else { gameOver(); } }
      }

      // Hotfix: 重用上方的 mgOn，不再重複宣告
      if(mgOn){
        state.mgFireTimer -= dt;
        if(state.mgFireTimer<=0){
          state.mgFireTimer=1.0/state.mgFireRate;
          const bx=dino.x+dino.w*0.5, by=dino.y+dino.h*0.45;
          state.pBullets.push({x:bx,y:by,w:12,h:3,v:720});
          if(audio.enabled) sfx.mgBurst();
        }
      }
      for(const pb of state.pBullets){ pb.x += pb.v*dt; }

      for(let i=state.pBullets.length-1;i>=0;i--){
        const pb=state.pBullets[i]; let collided=false;
        for(let j=state.obstacles.length-1;j>=0;j--){ const ob=state.obstacles[j]; if(intersects(pb,{x:ob.x,y:ob.y,w:ob.w,h:ob.h})){
          collided=true; const sx=ob.x+ob.w*0.6, sy=ob.y+ob.h*0.5; spawnSparks(sx,sy,26,380,0.75,5);
          if(ob.type==='jet'){
            if(Math.random()<0.6){ state.score+=150; state.obstacles.splice(j,1); if(audio.enabled) sfx.hit(); }
          } else if(ob.type==='dragon'){
            state.score+=90; state.obstacles.splice(j,1); if(audio.enabled) sfx.hit();
          } else { 
            state.score += (ob.type==='cactus'? 60 : 80); state.obstacles.splice(j,1); if(audio.enabled) sfx.hit();
          }
          break;
        }}
        if(collided || pb.x>W()+60){ state.pBullets.splice(i,1); }
      }

      for(const p of state.particles){ p.age+=dt; p.x+=p.vx*dt; p.y+=p.vy*dt; p.vy += 900*dt*0.6; }
      state.particles = state.particles.filter(p=> p.age<p.life);
    }

    function gameOver(){
      state.best=Math.max(state.best,Math.floor(state.score));
      state.running=false; state.dead=true; if(audio.enabled) sfx.over();
      tip.style.display='';
      tip.querySelector('.card').innerHTML=
        `<div style="font-size:18px; font-weight:800; margin-bottom:10px">遊戲結束！分數：${Math.floor(state.score)} · 最高：${state.best}</div>
         <div class="muted" style="font-size:14px; margin-bottom:10px">按 R 重新開始 · 空白鍵跳躍（可長按） · ↓/S 蹲下</div>
         <div id="tapRestart" style="display:flex;align-items:center;justify-content:center;gap:10px;user-select:none">
           <svg width="36" height="36" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M3 12a9 9 0 1 0 3-6.708" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M3 4v4h4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
           <span style="font-weight:700">點一下螢幕即可重來</span>
         </div>`;
      tip.querySelector('#tapRestart')?.addEventListener('pointerdown', ev=>{ ev.preventDefault(); restart(); });
    }

    /* =============================
       繪製
       ============================= */
    function drawGround(){ const y=groundY(); ctx.fillStyle=state.night?'#111827':'#e5e7eb'; ctx.fillRect(0,y,W(),H()-y); ctx.strokeStyle=state.night?'#374151':'#d1d5db'; ctx.lineWidth=2; ctx.beginPath(); const step=24; const offset=(state.time*state.speed*state.speedScale*0.2)%step; for(let x=-offset; x<W()+step; x+=step){ ctx.moveTo(x,y+10); ctx.lineTo(x+14,y+10); } ctx.stroke(); }
    function drawCloud(c){ ctx.save(); ctx.translate(c.x,c.y); ctx.beginPath(); const r=c.r; ctx.fillStyle=state.night?'rgba(255,255,255,.25)':'rgba(255,255,255,.9)'; ctx.arc(-r*0.6,0,r*0.6,0,Math.PI*2); ctx.arc(0,-r*0.2,r*0.8,0,Math.PI*2); ctx.arc(r*0.7,0,r*0.5,0,Math.PI*2); ctx.fill(); ctx.restore(); }

    function currentSkinTier(){ return Math.min(10, Math.floor(state.score/1000)); }

    function roundRect(x,y,w,h,r,fill){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); if(fill) ctx.fill(); else ctx.stroke(); }

    function getSkinForTier(tier){
      // tier 0: 基本灰；1~9：色相循環變化；>=10：金色（固定）
      if(tier>=10){ return { body:'#facc15', head:'#facc15', eye:'#0b1020', deco:'crown' }; }
      if(tier===0){ return { body:'#374151', head:'#374151', eye:'#111', deco:null }; }
      const hue = (tier*34)%360; // 1~9 漸變
      const body = `hsl(${hue} 70% 55%)`;
      const eye = '#0b1020';
      const pattern = tier % 3; // 1: headband, 2: wing, 0: none
      const deco = pattern===1? 'headband' : (pattern===2? 'wing' : null);
      return { body, head:body, eye, deco };
    }

    function drawDino(){
      const x=dino.x,y=dino.y,w=dino.w,h=dino.h; const tier=currentSkinTier();
      ctx.save();
      const gy=groundY();
      const sh=Math.max(4,14-(gy-(y+h))*0.06); ctx.fillStyle='rgba(0,0,0,.12)'; ctx.beginPath(); ctx.ellipse(x,gy+6,36,sh,0,0,Math.PI*2); ctx.fill();
      ctx.translate(x,y);

      const skin = getSkinForTier(tier);
      let body=skin.body, head=skin.head, eye=skin.eye, deco=skin.deco;

      const crouch=dino.crouch && dino.onGround;
      ctx.fillStyle=body; if(crouch){ roundRect(-w*0.35,h*0.25,w*0.7,h*0.45,10,true); ctx.fillStyle=head; roundRect(0,h*0.02,w*0.42,h*0.28,10,true); } else { roundRect(-w*0.35,h*0.05,w*0.7,h*0.55,10,true); ctx.fillStyle=head; roundRect(w*0.05,-h*0.15,w*0.45,h*0.35,10,true); }

      const t=state.time*10; const k=Math.sin(t)*6; ctx.fillStyle=body;
      if(crouch){ roundRect(-w*0.18,h*0.58,w*0.26,h*0.25,8,true); roundRect(0,h*0.58,w*0.26,h*0.25,8,true); }
      else { roundRect(-w*0.15,h*0.6,w*0.22,h*0.3,8,true); roundRect(w*0.02+k*0.02,h*0.6,w*0.22,h*0.3,8,true); }
      if(!crouch) roundRect(-w*0.3,h*0.25,w*0.18,h*0.12,6,true);

      ctx.fillStyle='#fff'; const eyeY=crouch? h*0.12 : -h*0.02; ctx.beginPath(); ctx.arc(w*0.38,eyeY,5,0,Math.PI*2); ctx.fill(); ctx.fillStyle=eye; ctx.beginPath(); ctx.arc(w*0.38,eyeY,2.4,0,Math.PI*2); ctx.fill();

      if(deco==='headband'){ ctx.fillStyle='#ef4444'; ctx.fillRect(w*0.02,(crouch? h*0.02 : -h*0.12),w*0.46,6); }
      else if(deco==='wing'){ ctx.save(); ctx.translate(-w*0.4,h*0.05); ctx.rotate(-0.4); ctx.fillStyle='hsl(160 80% 80%)'; ctx.beginPath(); ctx.moveTo(0,0); ctx.quadraticCurveTo(-28,-14,-52,0); ctx.quadraticCurveTo(-28,14,0,0); ctx.fill(); ctx.restore(); }
      else if(deco==='crown'){ ctx.save(); ctx.translate(w*0.22,(crouch? -h*0.06 : -h*0.22)); ctx.fillStyle='#facc15'; ctx.beginPath(); ctx.moveTo(0,8); ctx.lineTo(8,-6); ctx.lineTo(16,8); ctx.lineTo(24,-6); ctx.lineTo(32,8); ctx.lineTo(0,8); ctx.fill(); ctx.restore(); }

      if(state.time<state.invincibleUntil){ ctx.lineWidth=3; ctx.strokeStyle='rgba(250,204,21,.9)'; roundRect(-w*0.42,-h*0.22,w*0.95,h*1.1,16,false); }
      ctx.restore();
    }

    function drawCactus(ob){ const {x,y,w,h}=ob; ctx.save(); ctx.translate(x,y+h); ctx.fillStyle='#16a34a'; roundRect(-w*0.45,-h, w*0.9, h, 6, true); roundRect(-w*0.95,-h*0.58, w*0.35, h*0.44, 6, true); roundRect( w*0.60,-h*0.46, w*0.35, h*0.36, 6, true); ctx.restore(); }
    function drawJet(ob){ const {x,y,w,h}=ob; ctx.save(); ctx.translate(x,y); ctx.fillStyle=state.night? '#60a5fa' : '#111827'; ctx.beginPath(); ctx.moveTo(0,h*0.5); ctx.lineTo(w*0.55,h*0.5); ctx.lineTo(w*0.85,h*0.35); ctx.lineTo(w,h*0.5); ctx.lineTo(w*0.85,h*0.65); ctx.lineTo(w*0.55,h*0.5); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(w*0.22,0); ctx.lineTo(w*0.52,h*0.5); ctx.lineTo(w*0.22,h); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(w*0.12,h*0.2); ctx.lineTo(w*0.2,h*0.5); ctx.lineTo(w*0.12,h*0.8); ctx.closePath(); ctx.fill(); const flame=6+6*Math.sin(state.time*20); ctx.fillStyle=state.night? '#fbbf24' : '#f59e0b'; ctx.beginPath(); ctx.moveTo(-flame,h*0.5); ctx.lineTo(0,h*0.4); ctx.lineTo(0,h*0.6); ctx.closePath(); ctx.fill(); ctx.restore(); }
    function drawDragon(ob){ const {x,y,w,h}=ob; ctx.save(); ctx.translate(x,y); ctx.fillStyle = '#f59e0b'; roundRect(w*0.05,h*0.15,w*0.70,h*0.55,16,true); ctx.fillStyle = '#fde68a'; roundRect(w*0.16,h*0.36,w*0.46,h*0.28,10,true); ctx.fillStyle = '#f59e0b'; roundRect(-w*0.08,h*0.18,w*0.34,h*0.30,14,true); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(w*0.12,h*0.30,5,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(w*0.12,h*0.30,2.4,0,Math.PI*2); ctx.fill(); ctx.fillStyle = state.night? '#93c5fd' : '#10b981'; ctx.beginPath(); ctx.moveTo(w*0.38,h*0.18); ctx.quadraticCurveTo(w*0.78,0,w*0.98,h*0.18); ctx.quadraticCurveTo(w*0.72,h*0.34,w*0.38,h*0.22); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.moveTo(w*0.70,h*0.58); ctx.quadraticCurveTo(w*0.92,h*0.70,w*1.02,h*0.58); ctx.lineTo(w*0.86,h*0.52); ctx.closePath(); ctx.fill(); ctx.restore(); }
    function drawPalm(ob){ const {x,y,w,h}=ob; ctx.save(); ctx.translate(x+w*0.5,y+h); ctx.fillStyle='#8b5a2b'; roundRect(-w*0.25,-h,w*0.5,h,6,true); ctx.translate(0,-h); ctx.rotate(Math.sin(state.palmWaves + x*0.01)*0.06); const leaf=(ang)=>{ ctx.save(); ctx.rotate(ang); ctx.fillStyle='#10b981'; ctx.beginPath(); ctx.moveTo(0,0); ctx.quadraticCurveTo(32,-6,64,0); ctx.quadraticCurveTo(32,6,0,0); ctx.fill(); ctx.restore(); }; leaf(-0.6); leaf(0); leaf(0.6); ctx.restore(); }
    function drawMiniPowerup(p){ const {x,y,w,h}=p; ctx.save(); ctx.translate(x,y); ctx.fillStyle='#374151'; roundRect(0,h*0.25,w*0.8,h*0.6,6,true); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(w*0.6,h*0.45,2.5,0,Math.PI*2); ctx.fill(); ctx.restore(); }
    function drawFollower(x,y,scale=0.55){ ctx.save(); ctx.translate(x,y); const w=70*scale,h=70*scale; ctx.fillStyle='#4b5563'; roundRect(-w*0.35,h*0.05,w*0.7,h*0.55,8,true); ctx.fillStyle='#4b5563'; roundRect(w*0.05,-h*0.15,w*0.45,h*0.35,8,true); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(w*0.38,-h*0.02,3.2,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(w*0.38,-h*0.02,1.5,0,Math.PI*2); ctx.fill(); ctx.restore(); }
    function drawFollowers(){
      // 與本體同步姿勢，並放大與本體/彼此的距離（V4.9 調整）
      const baseY = dino.y + (dino.h - 40);
      const baseOffset = 50;  // 與本體的起始距離（原 26*1 -> 50）
      const stepOffset = 38;  // 每隻之間的距離（原 26 -> 38）
      for(let i=0;i<state.littles;i++){
        const offset = baseOffset + stepOffset * i;   
        const phase  = i*0.7;              
        const bob    = Math.sin(state.time*10 + phase) * 1.2; 
        const fy     = baseY + bob;
        drawFollower(dino.x - offset, fy);
      }
    }
    function drawBullet(b){ ctx.save(); ctx.translate(b.x,b.y); ctx.fillStyle=state.night? '#e5e7eb' : '#ef4444'; ctx.fillRect(0,0,b.w,b.h); ctx.restore(); }
    function drawChest(p){ const {x,y,w,h}=p; ctx.save(); ctx.translate(x,y); ctx.fillStyle='#f59e0b'; roundRect(0,0,w,h,4,true); ctx.fillStyle='#8b5a2b'; ctx.fillRect(0,h*0.5,w,h*0.18); ctx.fillStyle='#fff'; ctx.fillRect(w*0.48,h*0.2,w*0.04,h*0.6); ctx.fillRect(w*0.3,h*0.45,w*0.4,h*0.08); ctx.restore(); }
    function drawStar(p){ const {x,y,w,h,spin}=p; const r=Math.min(w,h)/2; ctx.save(); ctx.translate(x+w/2,y+h/2); ctx.rotate(spin); const spikes=5; let rot=Math.PI/2*3; const step=Math.PI/spikes; ctx.beginPath(); ctx.moveTo(0,-r); for(let i=0;i<spikes;i++){ ctx.lineTo(Math.cos(rot)*r,Math.sin(rot)*r); rot+=step; ctx.lineTo(Math.cos(rot)*r*0.5,Math.sin(rot)*r*0.5); rot+=step; } ctx.lineTo(0,-r); ctx.closePath(); ctx.fillStyle='#facc15'; ctx.fill(); ctx.restore(); }
    function drawGun(p){ const {x,y,w,h}=p; ctx.save(); ctx.translate(x,y); ctx.fillStyle=state.night? '#ffffff' : '#1f2937'; ctx.fillRect(0,h*0.35,w*0.85,h*0.35); ctx.fillRect(w*0.78,h*0.28,w*0.22,h*0.14); ctx.fillRect(w*0.18,0,w*0.2,h*0.35); ctx.restore(); }
    function drawPlayerBullet(pb){ ctx.save(); ctx.translate(pb.x,pb.y); ctx.fillStyle='#2563eb'; ctx.fillRect(0,0,pb.w,pb.h); ctx.restore(); }
    function drawOb(ob){ if(ob.type==='cactus') drawCactus(ob); else if(ob.type==='jet') drawJet(ob); else if(ob.type==='dragon') drawDragon(ob); else drawPalm(ob); }
    function drawParticles(){ for(const p of state.particles){ const t=p.age/p.life; const alpha=Math.max(0,1-t); ctx.save(); ctx.globalAlpha=alpha; const col=state.night? p.colorNight : p.colorDay; ctx.fillStyle=col; ctx.shadowColor=col; ctx.shadowBlur=8; ctx.fillRect(p.x,p.y,p.size,p.size*0.75); ctx.restore(); } }
    function draw(dt){ ctx.clearRect(0,0,canvas.width,canvas.height); for(const c of state.clouds) drawCloud(c); drawGround(); for(const ob of state.obstacles) drawOb(ob); for(const b of state.bullets) drawBullet(b); for(const p of state.powerups){ if(p.type==='chest') drawChest(p); else if(p.type==='star') drawStar(p); else if(p.type==='gun') drawGun(p); else drawMiniPowerup(p); } for(const pb of state.pBullets) drawPlayerBullet(pb); drawParticles(); drawFollowers(); drawDino(); }

    /* =============================
       自動化測試（console）
       ============================= */
    function runSelfTests(){
      const tests=[]; const assert=(n,c)=>tests.push({n,pass:!!c});
      assert('start() exists', typeof start==='function');
      assert('restart() exists', typeof restart==='function');
      assert('attemptQuickRestart() exists', typeof attemptQuickRestart==='function');

      try{ 
        state.obstacles.length=0; state.pBullets.length=0; const h=80,w=22; const ox=dino.x+120; const oy=groundY()-h; state.obstacles.push({type:'cactus',x:ox,y:oy,w,h}); state.pBullets.push({x:ox+2,y:oy+h*0.5,w:12,h:3,v:0}); const b0=state.obstacles.length; update(0); const b1=state.obstacles.length; assert('MG bullet destroys cactus', b1===b0-1);
      }catch(e){ assert('MG bullet destroys cactus (no error)', false); }

      try{ 
        state.obstacles.length=0; state.pBullets.length=0; const w=110,h=68; const ox=dino.x+140; const oy=groundY()-200; state.obstacles.push({type:'dragon',x:ox,y:oy,w,h,y0:oy,amp:80,freq:1.6,phase:0}); state.pBullets.push({x:ox+5,y:oy+h*0.5,w:12,h:3,v:0}); const a0=state.obstacles.length; update(0); const a1=state.obstacles.length; assert('MG bullet destroys dragon', a1===a0-1);
      }catch(e){ assert('MG bullet destroys dragon (no error)', false); }

      try{ 
        state.obstacles.length=0; state.bullets.length=0; const h=28,w=90; const yBase=groundY()-180; state.obstacles.push({type:'jet',x:dino.x+260,y:yBase,w,h,shootTimer:0.02,fired:false,y0:yBase,amp:20,freq:1,phase:0}); for(let i=0;i<30;i++) update(0.016); const count=state.bullets.length; for(let i=0;i<60;i++) update(0.016); assert('Jet fires once', count===1 && state.bullets.length===1);
      }catch(e){ assert('Jet fires once (no error)', false); }

      try{ 
        state.littles=0; state.powerups=[{type:'mini',x:dino.x,y:dino.y,w:20,h:20}]; update(0); const hpAfter=1+state.littles; assert('Pickup mini increases HP', hpAfter>=2);
      }catch(e){ assert('Pickup mini increases HP (no error)', false); }

      try{ 
        reset(); state.littles=2; state.obstacles=[{type:'cactus',x:dino.x+10,y:groundY()-60,w:22,h:60}]; update(0.016); const alive=!state.dead; const remaining=state.littles; assert('Hit reduces HP if littles>0', alive && remaining===1);
      }catch(e){ assert('Hit reduces HP if littles>0 (no error)', false); }

      try{ 
        state.score=1100; const before=state.night; update(0); assert('Night mode toggles after 1000', state.night===true || before!==state.night);
      }catch(e){ assert('Night mode toggles after 1000 (no error)', false); }

      try{ 
        reset(); state.powerups=[{type:'star',x:dino.x,y:dino.y,w:20,h:20,spin:0}]; const t0=state.time; update(0); assert('Pickup star sets invincibleUntil', state.invincibleUntil>t0);
      }catch(e){ assert('Pickup star sets invincibleUntil (no error)', false); }

      // 新增：機關槍（mgOn）自動發射測試
      try{
        reset(); state.mgUntil = state.time + 0.5; state.mgFireRate = 10; state.mgFireTimer = 0; const before = state.pBullets.length; update(0.016); const after = state.pBullets.length; assert('MG spawns bullets when active', after>before);
      }catch(e){ assert('MG spawns bullets when active (no error)', false); }

      console.group('%cSelf Tests','color:#10b981;font-weight:700');
      tests.forEach(t=>console[t.pass?'log':'error'](`${t.pass?'✅':'❌'} ${t.n}`));
      console.groupEnd();
    }

    reset();
    window.__runTests = runSelfTests;
  })();
  </script>
</body>
</html>
